(()=>{"use strict";class t extends HTMLElement{constructor(){super(),this.shadow=this.attachShadow({mode:"open"})}connectedCallback(){this.render()}render(){this.shadow.innerHTML="\n    <style>\n      h2 {\n          color: #E36374;\n      }\n      div {\n        display: block;\n        width: 200px;\n        height: 200px;\n      }\n    </style>\n    <div>\n      <h2>\n        dddddddddddd\n      </h2>\n    </div>\n    "}}customElements.define("test-component",t);class n extends HTMLElement{constructor(t,n,e,s){super(),this.shadow=this.attachShadow({mode:"open"}),this.events=new EventTarget,this.x=t,this.y=n,this.num=e,this.canvas=s,this.selectedAsFirst=!1,this.selectedAsSecond=!1,this.addEventListener("click",(t=>{t.stopPropagation(),t.preventDefault(),this.events.dispatchEvent(new Event("pointPressed"))}))}onPointPressed(t){this.events.addEventListener("pointPressed",t)}connectedCallback(){this.render()}render(){return this.shadowRoot.innerHTML=`\n        <style>\n          .point {\n            position: absolute;\n            display: block;\n            background-color: white;\n            border: 2px solid black;\n            font-size: 18px;\n            font-weight: bold;\n            color: #306573;\n            border-radius: 50%;\n            width: 10px;\n            height: 10px;\n            left: ${this.x-5}px; /* Сдвиг для центрирования */\n            top: ${this.y-5}px;  /* Сдвиг для центрирования */\n            z-index: 2;\n          }\n          .point::before {\n            content: 'p${this.num}';\n            position: absolute;\n            bottom: 15px;\n            z-index: 2;\n          }\n          .point:hover {\n            border: 2px solid rgb(38, 143, 235);\n            cursor: pointer;\n            color: rgb(38, 143, 235);\n          }\n          .point_selected {\n            background-color: #0197F6;\n          }\n        </style>\n        <div class="point ${(this.selectedAsFirst||this.selectedAsSecond)&&"point_selected"}">\n            \n        </div>\n      `}}customElements.define("my-point",n);class e extends HTMLElement{constructor(t,n,e,s,i){super(),this.shadow=this.attachShadow({mode:"open"}),this.x1=t,this.y1=n,this.x2=e,this.y2=s,this.active=!1,this.num=i}connectedCallback(){this.render()}render(){return this.shadowRoot.innerHTML=`\n      <style>\n      .vektor-container {\n        position: absolute;\n        pointer-events: none; /* Чтобы не мешать кликам по канвасу */\n        z-index: 1;\n        width: 100%;\n        height: 100%;\n      }\n      .vektor {\n\n      }\n      .line {\n        position: relative;\n        fill: none;\n        stroke-width: 4;\n        stroke: black;\n        z-index: 1;\n      }\n      .line_active {\n        stroke: rgb(38, 143, 235);\n      }\n    </style>\n      <div class="vektor-container">\n        <svg class="vektor" height="100%" width="100%" xmlns="http://www.w3.org/2000/svg">\n          <line class="line ${this.active&&"line_active"}" x1="${this.x1}" y1="${this.y1}" x2="${this.x2}" y2="${this.y2}" />\n        </svg> \n      </div>\n    `}}customElements.define("my-vektor",e);class s extends HTMLElement{constructor(){super(),this.isCanvasActive=!1,this.isPolygonDrawn=!1,this.firstPointSelectionFlag=!1,this.secondPointSelectionFlag=!1,this.isPathCreated=!1,this.pointArr=[],this.vektorArr=[],this.events=new EventTarget}connectedCallback(){this.render(),this.canvas=this.querySelector(".drawing-canvas"),this.canvas.addEventListener("click",(t=>{t.preventDefault(),t.stopPropagation(),this.renderPoint(t)})),this.events.addEventListener("pathesCreated",(t=>{this.vektorArr.forEach((t=>t.active=!1));const n=this.pointArr.map((t=>t.num)),e=t.detail;e.clockwisePath.filter((t=>e.clockwisePath.indexOf(t)!==e.clockwisePath.length-1)).map((t=>n.indexOf(t))).map((t=>this.vektorArr[t])).forEach((t=>{t.active=!0,t.render()})),this.isPathCreated=!0})),this.events.addEventListener("changeOrder",(()=>{this.vektorArr.forEach((t=>{t.active?(t.active=!1,t.render()):(t.active=!0,t.render())}))}))}handlePointPressed(t){this.firstPointSelectionFlag?(this.pointArr.map((t=>{t.selectedAsFirst=!1,t.render()})),t.selectedAsFirst=!0,this.events.dispatchEvent(new Event("pointSelected")),t.render()):this.secondPointSelectionFlag&&(this.pointArr.map((t=>{t.selectedAsSecond=!1,t.render()})),t.selectedAsSecond=!0,this.events.dispatchEvent(new Event("pointSelected")),t.render());const n=this.pointArr.find((t=>!0===t.selectedAsFirst)),e=this.pointArr.find((t=>!0===t.selectedAsSecond));n&&e&&this.events.dispatchEvent(new Event("twoPointsSelected"))}renderPoint(t){if(this.isCanvasActive&&!this.isPolygonDrawn){const e=this.canvas.getBoundingClientRect(),s=t.clientX-e.left,i=t.clientY-e.top,r=new n(s,i,this.pointArr.length+1,this);r.onPointPressed((()=>{this.handlePointPressed(r)})),this.pointArr.push(r),this.events.dispatchEvent(new Event("pointAdded")),this.canvas.appendChild(r)}}clearCanvas(){this.pointArr.forEach((t=>{this.canvas.removeChild(t)})),this.pointArr=[],this.vektorArr.forEach((t=>{this.canvas.removeChild(t)})),this.vektorArr=[],this.isCanvasActive=!1,this.events.dispatchEvent(new Event("pointsCleared")),this.isPolygonDrawn=!1,this.isPathCreated=!1}findCenterPoint(t){let n,e=0,s=0,i=t.length;for(n=0;n<i;n++)e+=t[n].x,s+=t[n].y;return{x:e/i,y:s/i}}findAngles(t,n){let e,s,i,r,o=n.length;for(e=0;e<o;e++)s=n[e],i=s.x-t.x,r=s.y-t.y,s.angle=Math.atan2(r,i);this.pointArr.sort((function(t,n){return t.angle>n.angle?1:t.angle<n.angle?-1:0}))}drawPolygon(){if(!this.isPolygonDrawn){let t=[];const n=this.findCenterPoint(this.pointArr);this.findAngles(n,this.pointArr);for(let n=0;n<this.pointArr.length;n++)n+1!==this.pointArr.length?t.push({x1:this.pointArr[n].x,y1:this.pointArr[n].y,x2:this.pointArr[n+1].x,y2:this.pointArr[n+1].y}):t.push({x1:this.pointArr[n].x,y1:this.pointArr[n].y,x2:this.pointArr[0].x,y2:this.pointArr[0].y}),this.isPolygonDrawn=!0,this.isCanvasActive=!1;this.pointArr.forEach(((n,s)=>{const i=new e(t[s].x1,t[s].y1,t[s].x2,t[s].y2,this.vektorArr.length+1);this.vektorArr.push(i),this.canvas.appendChild(i)}))}}render(){return this.innerHTML='\n      <style>\n        drawing-canvas {\n          display: flex;\n          flex-direction: row;\n          align-items: stretch;\n          width: 100%;\n          color: black;\n          border: 1px solid black;\n        }\n        .drawing-canvas {\n          position: relative;\n          width: 100%;\n          height: 100%;\n          background-color: white;\n          flex: 1;\n        }\n      </style>\n      <div class="drawing-canvas">\n      </div>\n    '}}customElements.define("drawing-canvas",s);class i extends HTMLElement{constructor(t){super(),this.canvas=t,this.events=new EventTarget,this.clockwisePath="",this.counterclockwisePath="",this.orderButtonText="Clockwise order",this.currentPath=this.clockwisePath}attachEventListeners(){this.querySelector(".action-panel").addEventListener("click",(t=>{t.target.classList.contains("create-point-button")?this.canvas.isCanvasActive=!0:t.target.classList.contains("clear-button")?(this.canvas.clearCanvas(),this.clockwisePath="",this.counterclockwisePath="",this.currentPath="",this.orderButtonText="Clockwise order",this.render()):t.target.classList.contains("draw-button")?(this.canvas.drawPolygon(),this.render()):t.target.classList.contains("first-point-button")?this.events.dispatchEvent(new Event("firstPointButtonPressed")):t.target.classList.contains("second-point-button")?this.events.dispatchEvent(new Event("secondPointButtonPressed")):t.target.classList.contains("order-button")&&(this.canvas.events.dispatchEvent(new Event("changeOrder")),"Clockwise order"===this.orderButtonText?(this.orderButtonText="Counterclockwise order",this.currentPath=this.counterclockwisePath.map((t=>"p"+t)).join("-")):(this.orderButtonText="Clockwise order",this.currentPath=this.clockwisePath.map((t=>"p"+t)).join("-")),this.render())}))}handlePath(){const t=this.canvas.pointArr.find((t=>t.selectedAsFirst)),n=this.canvas.pointArr.find((t=>t.selectedAsSecond));if(t&&n){const e=this.canvas.pointArr.map((t=>t.num)),s=t.num,i=n.num,r=this.makePathes(e,s,i);this.clockwisePath=r.clockwiseArr,this.counterclockwisePath=r.counterclockwiseArr,this.canvas.events.dispatchEvent(new CustomEvent("pathesCreated",{detail:{clockwisePath:this.clockwisePath,counterclockwisePath:this.counterclockwisePath}}))}}makePathes(t,n,e){const s=t.indexOf(n),i=t.indexOf(e);let r=[],o=[];for(let n=s;n%t.length!==i;n++)r.push(t[n%t.length]);r.push(t[i]);const a=t.reverse(),c=a.indexOf(n),h=a.indexOf(e);for(let t=c;t%a.length!==h;t++)o.push(a[t%a.length]);return o.push(a[h]),{clockwiseArr:r,counterclockwiseArr:o}}connectedCallback(){this.render();const t=this.canvas;t.events.addEventListener("pointAdded",(()=>this.render())),t.events.addEventListener("pointsCleared",(()=>this.render())),this.events.addEventListener("firstPointButtonPressed",(n=>{t.secondPointSelectionFlag=!1,t.firstPointSelectionFlag=!0})),this.events.addEventListener("secondPointButtonPressed",(n=>{t.firstPointSelectionFlag=!1,t.secondPointSelectionFlag=!0})),t.events.addEventListener("pointSelected",(()=>this.render())),t.events.addEventListener("twoPointsSelected",(()=>{this.canvas.vektorArr.forEach((t=>{t.active=!1,t.render()})),this.handlePath(),"Clockwise order"===this.orderButtonText?this.currentPath=this.clockwisePath.map((t=>"p"+t)).join("-"):this.currentPath=this.counterclockwisePath.map((t=>"p"+t)).join("-"),this.render()}))}render(){const t=this.canvas.pointArr.length,n=!(t>0),e=!(t>=3&&t<=15)||this.canvas.isPolygonDrawn,s=!this.canvas.isPolygonDrawn,i=this.canvas.isPolygonDrawn,r=!this.canvas.isPathCreated,o=this.canvas.pointArr.find((t=>t.selectedAsFirst)),a=this.canvas.pointArr.find((t=>t.selectedAsSecond)),c={};this.canvas.pointArr.forEach((t=>{c[t.num]=t}));const h=this.currentPath;this.innerHTML=`\n      <style>\n        .action-panel {\n          display: flex;\n          flex-direction: column;\n          gap: 30px;\n          width: 350px;\n        }\n        .action-panel_active {\n          border: 1px solid green;\n        }\n        .main-paragraph {\n          font-size: 22px;\n          font-weight: bold;\n        }\n        .path {\n          display: flex;\n          flex-direction: column;\n          gap: 15px;\n        }\n        .button {\n          font-size: 16px;\n          padding: 10px 20px;\n          width: 100%;\n          border: none;\n          border-radius: 8px;\n        }\n        p {\n          margin: 5px 0px;\n        }\n        .first-point-button {\n          max-width: 260px;\n        }\n        .second-point-button {\n          max-width: 260px;\n        }\n        .path-button-container {\n          display: flex;\n          gap: 30px;\n          align-items: flex-start;\n        }\n      </style>\n      <div class="action-panel">\n        <div>\n          <p class="main-paragraph">Create polygon</p>\n          <button class="button create-point-button" ${i&&"disabled"}>Create points</button>\n          <points-component numbers="${t}"></points-component>\n          <button class="button draw-button" ${e&&"disabled"}>Draw polygon</button>\n        </div>\n        <div>\n          <p class="main-paragraph">Create path</p>\n          <div class="path">        \n            <div class="path-button-container">\n              <button class="button first-point-button" ${s&&"disabled"}>First point:</button>\n              <p>${o?`p${o.num}`:""}</p>\n            </div>\n            <div class="path-button-container">\n              <button class="button second-point-button" ${s&&"disabled"}>Second point:</button>\n              <p>${a?`p${a.num}`:""}</p>\n            </div>\n            <button class="button order-button" ${r&&"disabled"}>${this.orderButtonText}</button>\n            <button class="button clear-button" ${n&&"disabled"}>Clear</button>\n          </div>\n        </div>\n        <p class="main-paragraph">Path: ${h}</p>\n      </div>\n    `,this.attachEventListeners()}}customElements.define("action-panel",i);class r extends HTMLElement{constructor(){super()}connectedCallback(){this.render();const t=document.querySelector(".container"),n=new s;t.appendChild(n),setTimeout((()=>{const e=new i(n);t.appendChild(e)}),0)}render(){return this.innerHTML='\n      <style>\n        .container {\n          display: flex;\n          justify-content: center;\n          gap: 30px;\n          max-width: 900px;\n        }\n      </style>\n      <div class="container"></div>\n      '}}customElements.define("app-initializer",r);class o extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"});const t=this.getAttribute("numbers"),n=document.createElement("style");n.textContent=`\n        p {\n          color: ${t>=3&&t<=15?"#1bcc35":"#DC2E45"};\n        }\n      `,this.paragraph=document.createElement("p"),this.shadowRoot.append(n,this.paragraph)}connectedCallback(){this.updateNumbers()}static get observedAttributes(){return["numbers"]}attributeChangedCallback(t,n,e){"numbers"===t&&this.updateNumbers()}updateNumbers(){const t=this.getAttribute("numbers");t&&(this.paragraph.textContent=`Created ${t} points`)}}customElements.define("points-component",o);class a extends HTMLElement{constructor(){super(),this.shadow=this.attachShadow({mode:"open"})}connectedCallback(){this.render()}render(){this.shadow.innerHTML="\n            <style>\n                h1 {\n                    color: red;\n                }\n            </style>\n            <h1>\n                Drawing Canvas:\n            </h1>\n        "}}customElements.define("hello-world",a)})();